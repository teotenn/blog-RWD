[{"content":"Scope of this post When you prepare for a job interview one of the questions they always tell you to prepare is \u0026ldquo;What are you most proud of?\u0026rdquo;. Personally I\u0026rsquo;ve never been asked that question in a job interview but it kept me thinking. Some years ago I developed the R code for the creation of maps of infrastructure for a Political Sciences project, and I can say that this is one of the projects I\u0026rsquo;m most proud of. However, it is also true what they say to developers, that nobody cares about how you did it. The final user only cared about what was done, while the research team about what are the possibilities. Due to the confidentiality agreement of the client, I also cannot share a git repository.\nThe project taught me so much in terms of technical skills that I have decided to share the how in case it can help somebody else. It is also my way to contribute to the R community since I myself learned R and programming thanks to the kind people who post their experience on the web (and to the ones who have the patience to answer questions in StackOverflow too).\nWe created maps of data showing changes over a span of time for different countries and pointing at all kinds of cities. That basically means that we need to map any region of the world with R. Today there are all kinds of packages and techniques to do that. I will share the strategy I used with ggplot2 and maps packages, using support of Open Street Map to obtain the coordinates of cities and finally making it interactive with shiny. The project is quite long for a single post, so my idea is to split it into a few smaller blog posts. The list can still change but I thought something like this:\n1. The basic map 2. Web scrapping with nominatim open street maps 3. Maps with cities 4. Dynamic maps in time 5. Making a single script for fast replication 6. Making the code interactive in a shiny app I hope you all enjoy it. Feel free to leave any kind of comment and/or question at the end.\nBackground When I joined the team all what they knew is that the wanted to make maps of infrastructure (say hospitals, cafes, churches, public offices, etc., but the project can basically be applied to anything countable per city). The maps should change in time according to the data (usually growth) and it should be possible to apply it for any country and thus, any kind of city of that particular country can be listed there. This last point represents a challenge because to make a map you need the coordinates of a particular point to map, but instead we got address in the best scenario, or only city name in the worst. Therefore, we left it to the level of city and decided to work with that.\nMost R packages to make maps have granularity up to some regions and major cities per country, and we are talking about countries where somebody has develop some R package for that. However, even the best packages would miss some cities or some countries some times. We needed to standardize everything without the need of changing packages according to the particular country. Before I joined, the team attempted to use Google Maps and excel, but the amount of data became messy and the flexibility to edit the maps was pretty limited. And they didn\u0026rsquo;t want to add copyright issues to the list of limitations. Therefore I proposed to use R. Of course, nobody in the team had ever heard about it before. We could had used any other tool, I learned that both, Python and JavaScript have some decent possibilities. But R is what I have been using for the last 10 years and is what I wanted to use for this project. And so I started to code.\nThe first couple of maps were custom code for a particular country with decent styles. But it quickly evolved into a set of functions and arguments to maintain the same standards for each map. The support of graphic designers also took the styles to a very professional level. After a few months we had very professional maps that could be done in couple of hrs (or less) with a couple of lines of code. Each map per each country with the desired span of years to be printed.\nI don\u0026rsquo;t think I will share every single detail of it, but at least I want to show how we went from the basic map to its dynamic form mapping over a span of time, and how I wrapped it all together in a couple of functions to make it quickly replicable for any given data set. Let me know what you think.\nHow to create a map of any country in R using the library maps The first step is to create the basic map of a country. Here is the function to achieve exactly that.\nlibrary(maps) library(ggplot2) ## make a df with only the country to overlap map_data_es \u0026lt;- map_data('world')[map_data('world')$region == \u0026quot;Spain\u0026quot;,] ## The map (maps + ggplot2 ) ggplot() + ## First layer: worldwide map geom_polygon(data = map_data(\u0026quot;world\u0026quot;), aes(x=long, y=lat, group = group), color = '#9c9c9c', fill = '#f3f3f3') + ## Second layer: Country map geom_polygon(data = map_data_es, aes(x=long, y=lat, group = group), color = 'red', fill = 'pink') + coord_map() + coord_fixed(1.3, xlim = c(-13.5, 8.5), ylim = c(34, 45)) + ggtitle(\u0026quot;A map of Spain\u0026quot;) + theme(panel.background =element_rect(fill = 'blue')) We are using the library maps in combination with ggplot2. The maps package contains coordinates system for a map of the whole world separated by countries (although political borders might not be fully up to date). It can as well do the maps, but for that we are making use of ggplot2 support here.\nWe start by extracting the data relevant to the country we want to map, in this case Spain. It is of course important to pass the name of the country in the same way that it is written in map_data('world')$region. You can use the function unique() to find the exact names of all the countries included in the packages (unique(map_data('world')$region) gives 252 countries at the moment of writing this post).\nOnce we have the data for the one particular country, we could simply map it directly using geom_polygon() however, that would map Spain surrounded by empty space around it. To place it in the context of its neighborhood, we apply two layers of geom_polygon(): first one with the map of the whole world and secondly the map of the country only.\nThen we need to tell ggplot to use a coordinates system to create maps instead of just polygons. For that we use coord_map() function and then we pass the details of the map ratio, and limits in X and Y to the function coord_fixed().\nUp to here we can have our map. ggplot is basically plotting what we are specifying inside the coordinates system, everything around it (the oceans) will be just empty and it will be filled in by the default grids and gray colors of ggplot(). Thus, we need to define the color of the Oceans as the background color for the whole plot. That\u0026rsquo;s what the last line of code does.\nOf course there are a lot of improvements to do. So far I have given exaggerated colors to make obvious for the reader which piece of code controls what. In that sense you can see that you can simply pass the names of the colors, which applies the defaults, or you can be more specific and provide the html notation of the color (i.e., '#9c9c9c'). So, let\u0026rsquo;s now improve the visuals and at the same time create a function to plot any country we want to.\nFunction to create the basic map in R map_country \u0026lt;- function(country, x_limits = NULL, y_limits = NULL){ ## Verifying the arguments passed to the function if(!is.character(country)) stop(\u0026quot;Name of the country should be character\u0026quot;) if(length(country) != 1) stop(\u0026quot;Function supports only one country per map\u0026quot;) ## Load libraries require(maps) require(ggplot2) if(!country %in% map_data('world')$region) stop('Country name not recognized\\nTo see a list of recognized countries run \u0026lt;unique(maps::map_data(\u0026quot;world\u0026quot;)$region)\u0026gt;') ## If coords limits missing, print worldwide map with coordinates system to allow ## User observe coords for reference if(missing(x_limits) || missing(y_limits)) { warning(\u0026quot;X and/or Y limits not provided.\\nPrinting worldwide map.\u0026quot;) map_country_theme \u0026lt;- theme(panel.background = element_rect(fill = '#4e91d2')) } else { if(length(x_limits) != 2 || length(y_limits) != 2 || !all(grepl('^-?[0-9.]+$', c(x_limits, y_limits)))){ stop(\u0026quot;Limits for X and Y coords should be provided as vectors with two numeric values\u0026quot;) } else { ## All the received inputs are correct. ## Let's define our custom theme for the final map map_country_theme \u0026lt;- theme_bw() + theme(panel.background = element_rect(fill = '#4e91d2'), legend.position = 'none', panel.grid.major = element_blank(), panel.grid.minor = element_blank(), axis.line = element_line(colour = \u0026quot;black\u0026quot;), axis.title.x=element_blank(), axis.text.x=element_blank(), axis.ticks.x=element_blank(), axis.title.y=element_blank(), axis.text.y=element_blank(), axis.ticks.y=element_blank()) } } ## make a df with only the country to overlap map_data_country \u0026lt;- map_data('world')[map_data('world')$region == country,] ## The map (maps + ggplot2 ) ggplot() + ## First layer: worldwide map geom_polygon(data = map_data(\u0026quot;world\u0026quot;), aes(x=long, y=lat, group = group), color = '#9c9c9c', fill = '#f3f3f3') + ## Second layer: Country map geom_polygon(data = map_data_country, aes(x=long, y=lat, group = group), color = '#4d696e', fill = '#8caeb4') + coord_map() + coord_fixed(1.3, xlim = x_limits, ylim = y_limits) + ggtitle(paste0(\u0026quot;A map of \u0026quot;, country)) + scale_x_continuous(n.breaks = 20) + scale_y_continuous(n.breaks = 20) + map_country_theme } ## Test the function with a different country map_country(\u0026quot;Germany\u0026quot;, c(-2, 22), c(47, 55)) Although the function might seem complicated at first, it is in fact the same code as we used to create the map, but instead of typing directly the name of the country or the limits for X and Y, we replace them with the arguments country, x_limits and y_limits respectively; in that way all the parts were we had the string \u0026quot;Spain\u0026quot; we now have the argument country, and so on. These are the only arguments that we need to change when we want to map a different country. You can define more arguments in case you want to have more possibilities to be editable, for example, we could define an argument country_color to specify the color we want for the target country. In our case we wanted to keep the same standards for all the maps due to branding reasons and thus, we rather wanted to have the exact same colors and styles for all of our maps.\nThere are also some additions on the top before the actual code to make the maps, all the if and else statements that are simply used to validate that the information passed by the user is the info that we actually need to make the function work. If any incorrect argument is passed to the function, we stop the process and write a message of what is wrong using the function stop(). For the case that no limits of either X or Y are defined, I send a warning message using warning(). In that case the process continues but we define a theme() that allows the user to see the country in the context of the worldwide map, with excess of values in the X and Y axes to provide the points of reference and give an idea of where to set the limits. By the end, when we ensure that all the values are fine, we define the final theme that we actually want to apply. About that, probably I should make special mention of !all(grepl('^-?[0-9.]+$', c(x_limits, y_limits)))): it is used to ensure that X and Y limits are of type numeric. See the visualization of the code below together with the help of the function(s) you don\u0026rsquo;t understand for a more detail explanation. Feel free to test the errors and warnings by providing to the function no country names or letters where there should be numbers, etc.\nThe lower part of the function is exactly the same as our first map, replacing the actual values for the arguments. We also have changed the colors for more specific ones. Almost by the end of the function we have added scale_x_continuous(n.breaks = 20) which will add 20 marks of the X axis scale (same for Y). We want to use it to ensure that, in case the user doesn\u0026rsquo;t have idea of which limit values to choose, it can have a good approach regarding the position of the target country. In case that both limits for X and Y are passed to the function, our other theme will mask this 20 breaks with axis.text.x = element_blank() and axis.ticks.x = element_blank().\nThe final line is the test that our function can plot a map other than Spain, in this case I chose Germany. We can basically choose any country included in the maps package and now make the map with the same standards in one line of R code.\nFinal remarks Here I am somehow showing one of the methods I use to create functions: I basically write first the code of what I want to achieve and once it does exactly what I want, I wrap it in a function, replacing the arguments that the user will need to modify later. Then I think what could go wrong and create the corresponding warnings an errors. It is a good practice to do that not only for the user to know better how to use the function, but also for yourself, it proves very useful when we need to debug code. Another good practice in R functions is the call to the libraries inside the function using require(). Even if you are writing many functions that use the same libraries, is good to repeat it on each function to make it self contained and again, help yourself in the debugging process. Not long ago I started collaborating in a project where there was no call to the libraries per function, but rather only at the top level when the main action of the program was called. This made almost impossible for me to test and debug code so, the first activity I did as a new member of the team was to spend 2 full working days adding require() where necessary.\nI hope you get some fun mapping different countries. Because different countries have different sizes and shapes, one way to improve the visuals related to this is by adjusting the ratio, for example, my own map of Germany looks out of shape, but it improves considerably if instead of 1.3 we give a ratio of 1.4, check the documentation to learn more about it.\nOnce that we have the basic map, we could add the cities were we want to add data values. Unfortunately, for cities there are many limitations, specially for countries where no special packages has been created to be mapped, and even there, most packages of particular countries don\u0026rsquo;t contain all the cities, especially minor ones. Thus, in our second part I will show how I tackled this problem doing some web scrapping to open street maps.\n","date":"2022-10-04","permalink":"https://blog-rwd-test.onrender.com/post/map_any_region_with_ggplot2_part_i/","tags":["R maps","ggplot2","Code Visuals","R functions"],"title":"Map any region in the world with R - Part I: The basic map"},{"content":"Welcome to R minitutorials of R White Dwarf Since the beginning of this year I\u0026rsquo;ve been forced to abandon completely the blog for countless and rather abstract personal reasons that include personal health, family matters and changes in my daily activities including volunteer work as well as main job. As part of the last, I finally got hired for a position as R developer, which brings great joy to me.\nThus, I\u0026rsquo;ve been using R more lately in all kinds of forms, including review and debug of small or simple code pieces that can result in practical quick hints for other R users, especially beginners or people with not much experience using R.\nWith that aim in mind while regaining a little bit of my free time and a piece of mental stability, and celebrating my new position, I decided to take care of the blog again with simple yet useful posts called minitutorials, starting with a very simple, even silly, but useful example.\nI hope they can be useful for you or your friends. Enjoy them!\nMinitutorial: make_logical_any_string A function to make logical any string\nmake_logical_any_string \u0026lt;- function(a_string){ a_string \u0026lt;- as.character(a_string) logical_result \u0026lt;- as.logical(a_string) if(is.na(logical_result)){logical_result \u0026lt;- FALSE} return(logical_result) } The function takes any value, convert it to character and returns TRUE ONLY IF the value takes either of the following forms: \u0026quot;T\u0026quot;, \u0026quot;TRUE\u0026quot;, \u0026quot;True\u0026quot;, \u0026quot;true\u0026quot; or TRUE, the last one the logical value, not the string.\nLogic of the function The function as.character() will convert any of the true strings listed above into a logical TRUE. If the string is rather \u0026quot;False\u0026quot; or its equivalent forms, the function will return FALSE. If any other character is passed to the function, the result will be NA. Therefore, we need to tweak the results when NA\u0026rsquo;s are produced since we forcefully need a True/False result. Thus, we implement if(is.na(logical_result)){logical_result \u0026lt;- FALSE} which will force any other string to return FALSE.\nWe are using this code for running R scripts in the terminal which passes a series of arguments for its functioning, some of which are required to be TRUE only when specified so, and FALSE in any other case, hence the trick of converting any other value to FALSE rather than NA.\nSomething to keep in mind is that the arguments are always passed to R script as character and thus, I wrote the example for this post converting everything into character in the first line of the function, which is not necessary in our original code executed in the terminal. In this way, if any number is passed to the function, it will also return FALSE, emulating what would happen if a number is entered into the console. This behavior is different for the function as.logical() itself, which returns FALSE if you enter the numerical value 0 and TRUE if any other numerical value is passed.\n","date":"2022-09-18","permalink":"https://blog-rwd-test.onrender.com/post/minitut_makebool/","tags":["minitutorial","R functions","R tips"],"title":"Minitutorial: make_logical any string"},{"content":"I am happy and excited as I have just deployed my first shiny app on the web. You can find it running at shiny.rwhitedwarf.com (NOTE: I don\u0026rsquo;t have ssl certificate so, your browser might tell you that is not secure, but you can trust me that there\u0026rsquo;s no risk). I have created a few shiny apps in the past but I never deployed one, especially in an owned domain.\nThe app can create a map of all cities listed in a table for a given country. The idea is to simulate a table with a list of organizations, franchises, shops, etc. However, columns for name of organization or ID are missing in order to ensure data protection. In this way the user only needs to provide to the table name of the city, country, region (optional) and year of opening. The app creates the map, placing bigger dots in cities with more organizations. The year is interactive.\nThe app uses the package RJSONIO to do a simple web scrapping on Open Street Maps using its API Nominatim to obtain the coordinates (latitude and longitude), in this way any city that can be found in open street maps can be pointed in the map. The data is then sorted and cleaned with some basic R functions and some Tidyverse and finally the map is made with ggplot2 and maps. The front end is created of course with shiny and css but I have to mention also the use of rhandsontable, a wonderful package that allows the user to interact with the tables and therefore, the data. The app was very easily deployed in heroku thanks to the wonderful work of Chris Stefano who did all the hard work of creating a buildpack for applications written in R. The buildpack recognizes shiny and plumber apps. For shiny, it builds based on the run.R file and installs all the packages listed in init.R, making the deployment in heroku extremely easy.\nThe app is still in a raw state but already functional. The plan is to improve both, the functionality and the view in the following days. If you are interested in the source code to get inspiration or create your own, you can find it on github under the MIT license: teotenn/dynamic_maps_shiny.\nIf you want to learn how to make a similar shiny app, stay connected for a 3-4 part tutorial to get full details step by step.\n","date":"2021-12-20","permalink":"https://blog-rwd-test.onrender.com/post/first_shiny_app/","tags":["R shiny"],"title":"My first shiny app"},{"content":"This post is part of our series on functions in R. You can see our previous post if you want to understand the basics but it is not strictly necessary. Here we will go into detail about for loops and if statements in R, two key elements of any function. We are going to define a process, map it in a step-by-step approach and wrape it in a function that can repeat it automatically. Even if you have a very basic understanding of R you should be able to follow this tutorial without problem.\nOur outcome will be an R function that by calling it, is able to fill in empty rows generated from imported sheets (like excel) when it contains merged cells. If you are only interested in the function itself you can go to the end of the post and find it in the section Final remarks.\nDescription of the problem In our previous post we saw the basics for creating functions, yet using silly examples with not much of practical usage. Now we are ready to write a function that can have more practical use.\nThere are different ways how to import data sheets (i.e. from excel) to R. Regardless of its limitations, these sheets are widely used in data analysis today. If you are used to do data analysis with a different software you should be familiar with the complications of sorting your data imported from sheets when there are merged cells in the rows. Usually, a file like below\nresults in a table like this\nSpecie Dup Treat Rep Value A. cap A 0 1 34 AA NA NA 26 A 25 NA 18 AA NA NA 24 A 50 NA 11 AA NA NA 12 A 100 NA 15 AA NA NA 11 F. rub F 0 NA 25 FF NA NA 26 F 25 NA 17 FF NA NA 11 F 50 NA 13 FF NA NA 11 F 100 NA 11 when the amount of rows to be filled in is small, there\u0026rsquo;s no big problem in copying and pasting the values. But as the DRY principle says, if we know how to create functions there is no need to do that, we can make a function that will do it automatically. This will specially pay off when you will have a table with hundreds or even thousands of cells merged. You might be thinking that nobody will merge cells for thousands of rows every 3 or 4 lines, but believe me, I have seen such things.\nKeep in mind that this is mainly a tutorial for writting functions in R. It does not intend to deal with all the issues that migh appear with the importing of data such as merged columns or a mixture of both, among others. But if you have problems with that or are interested in the topic, leave us a comment and we can cover some points in a future post.\nR function to fill in merged cells from excel With today\u0026rsquo;s technology there are many ways to solve this problem. However sometimes the easiest way to import data to R as data analyst or statistician is by simply taking the working sheet containing the data and exporting it in csv format.\nRegardless of the source (excel, libre office, google sheets, etc.) this method produces empty rows by default. When some rows have been merged because they belong to the same group or factor, the csv file will capture the value only on the first row and leave the rest empty until the next factor appear, where it again, will capture the value on the first row and leave the rest empty until the next factor appears. The process continues like this, iteratively until the end of the table. We basically need to copy the value stored on that first row and paste it to the empty rows, until a new factor appears.\nLet\u0026rsquo;s map the process in terms of R steps to complete our task.\nMaping the process We will start by calling the table. If you have an excel, libre office calc or google sheet file with merged rows as our example above feel free to use it. Otherwise you can quickly simulate one similar to the image above. Start by exporting the sheet of interest to csv, then we call it using read.csv\nmy.table \u0026lt;- read.csv('../../../static/post/2021/fill_merged_cells/Hydroponic_results.csv') head(my.table, n = 10) \u0026gt; Specie Dup Treat Rep Value \u0026gt; 1 A. cap A 0 1 34 \u0026gt; 2 AA NA NA 26 \u0026gt; 3 A 25 NA 18 \u0026gt; 4 AA NA NA 24 \u0026gt; 5 A 50 NA 11 \u0026gt; 6 AA NA NA 12 \u0026gt; 7 A 100 NA 15 \u0026gt; 8 AA NA NA 11 \u0026gt; 9 F. rub F 0 NA 25 \u0026gt; 10 FF NA NA 26 Here we can see the first 10 rows containing NA for numeric columns and empty string for character columns. Now let\u0026rsquo;s go step by step to fill empty values.\n1. Identify and capture the factor Let\u0026rsquo;s start with the first column Specie (an experiment was run for 3 different species of plants). We want to check if the first row contains a categorical value\nno.row \u0026lt;- 1 my.table[['Specie']][no.row] \u0026gt; [1] \u0026quot;A. cap\u0026quot; 2. Copy it into the empty rows Now we want to paste the value stored in category to all empty rows. So we first need to check if the next row is empty\nno.row \u0026lt;- 2 my.table[['Specie']][no.row] \u0026gt; [1] \u0026quot;\u0026quot; And when it is, we place the value contained in the previous row to our current row 2\nmy.table[['Specie']][no.row] \u0026lt;- my.table[['Specie']][no.row-1] head(my.table) \u0026gt; Specie Dup Treat Rep Value \u0026gt; 1 A. cap A 0 1 34 \u0026gt; 2 A. cap AA NA NA 26 \u0026gt; 3 A 25 NA 18 \u0026gt; 4 AA NA NA 24 \u0026gt; 5 A 50 NA 11 \u0026gt; 6 AA NA NA 12 Now row 2 contains it\u0026rsquo;s categorical value, and when we move to row 3 (which is also empty), it can be copied from the previous row 2\nno.row \u0026lt;- 3 my.table[['Specie']][no.row] \u0026gt; [1] \u0026quot;\u0026quot; my.table[['Specie']][no.row] \u0026lt;- my.table[['Specie']][no.row-1] head(my.table) \u0026gt; Specie Dup Treat Rep Value \u0026gt; 1 A. cap A 0 1 34 \u0026gt; 2 A. cap AA NA NA 26 \u0026gt; 3 A. cap A 25 NA 18 \u0026gt; 4 AA NA NA 24 \u0026gt; 5 A 50 NA 11 \u0026gt; 6 AA NA NA 12 3. When a new factor appears, repeat the process We can repeat this process until a new factor appears, as it is the case of row 9. Therefore we should not paste anything in row 9, and continue the process on row 10 which is also empty\nno.row \u0026lt;- 10 my.table[['Specie']][no.row] \u0026gt; [1] \u0026quot;\u0026quot; my.table[['Specie']][no.row] \u0026lt;- my.table[['Specie']][no.row-1] head(my.table, n = 10) \u0026gt; Specie Dup Treat Rep Value \u0026gt; 1 A. cap A 0 1 34 \u0026gt; 2 A. cap AA NA NA 26 \u0026gt; 3 A. cap A 25 NA 18 \u0026gt; 4 AA NA NA 24 \u0026gt; 5 A 50 NA 11 \u0026gt; 6 AA NA NA 12 \u0026gt; 7 A 100 NA 15 \u0026gt; 8 AA NA NA 11 \u0026gt; 9 F. rub F 0 NA 25 \u0026gt; 10 F. rub FF NA NA 26 4. Repeat steps 1-3 for each column that needs it The process moves forward in this way until the whole column Specie is filled in. Then we can move to the next column with empty values, in my case this is Treat.\nIf you look at the process, we basically need to write an R command for step 2. The rest is just a process of verification and repetition. We are going to automate verification using the function if() and the repetition using for().\nWriting my first for loop Since the present post is directed to R beginners with not much experience with programming or coding I will avoid all the technicalities of for loops and if statements and instead dive deeply into them by applying our logic above. Then we are going to use them and explain carefully to obtain a pragmatic understanding of the process.\nWe will start with a for loop to go row by row in one column and check what is inside, as described in the step 1 of our process. Let\u0026rsquo;s start with only 20 rows as an example\nfor(no.row in 1:20){ print(my.table[[\u0026quot;Specie\u0026quot;]][no.row]) } \u0026gt; [1] \u0026quot;A. cap\u0026quot; \u0026gt; [1] \u0026quot;A. cap\u0026quot; \u0026gt; [1] \u0026quot;A. cap\u0026quot; \u0026gt; [1] \u0026quot;\u0026quot; \u0026gt; [1] \u0026quot;\u0026quot; \u0026gt; [1] \u0026quot;\u0026quot; \u0026gt; [1] \u0026quot;\u0026quot; \u0026gt; [1] \u0026quot;\u0026quot; \u0026gt; [1] \u0026quot;F. rub\u0026quot; \u0026gt; [1] \u0026quot;F. rub\u0026quot; \u0026gt; [1] \u0026quot;\u0026quot; \u0026gt; [1] \u0026quot;\u0026quot; \u0026gt; [1] \u0026quot;\u0026quot; \u0026gt; [1] \u0026quot;\u0026quot; \u0026gt; [1] \u0026quot;\u0026quot; \u0026gt; [1] \u0026quot;\u0026quot; \u0026gt; [1] \u0026quot;A. ela\u0026quot; \u0026gt; [1] \u0026quot;\u0026quot; \u0026gt; [1] \u0026quot;\u0026quot; \u0026gt; [1] \u0026quot;\u0026quot; The function for()uses the first argument that you define (here no.row) and goes one by one in the series specified as the second argument, in this case a series of numbers from 1 to 20 (1:20). It means that in the first iteration no.row will take the value 1, in the second iteration the value 2, and so on, until the last iteration where it will have the value 20. Each iteration will execute the code inside the curly braces {} which, in this case, is simply to print the value of each row.\nBecause the first argument in for() is defined by us, we could as well use any arbitrary argument we want, for example\nfor(n in 1:20){ print(my.table[[\u0026quot;Specie\u0026quot;]][n]) } would do exactly the same but now n is taking the values from 1 to 20.\nWe can then initialize a function that takes the name of our data frame, the name of the column, and do exactly the same as our code above, but for all the rows contained in the table, no matter how many they are\nfill_merged \u0026lt;- function(dat, column){ ## Get value of each row for(n in 1:nrow(dat)){ print(my.table[[column]][n]) } } Here our for loop will create a local variable n that will take values from 1 until nrow(dat) which means number of rows in the table dat, and then print each row value contained in the column stated in the argument column. If we apply it to our data frame\nfill_merged(my.table, \u0026quot;Specie\u0026quot;) The R console will print, one by one, each of the values contained in the column Specie (I have 120 rows, it makes no sense to take space to show it in the post, but you can go ahead and try it yourself).\nIf the last two pieces of code are not clear for you, I recommend you to read our previous post about functions in R.\nHow to use If statement in R Printing the values is far from what we want to achieve. As we defined in the first step of the process, we need to check the value inside, if it has a value we leave it alone, but if it is empty, we fill it in with the previous value. To check if the value is empty or not we use the if() function\nfill_merged \u0026lt;- function(dat, column){ ## Get value of each row for(n in 1:nrow(dat)){ ## Check if it is empty if(dat[[column]][n] == ''){ dat[[column]][n] \u0026lt;- dat[[column]][n - 1] } } return(dat) } The function if() checks the expression inside parentheses and if it returns TRUE it executes the code inside curly braces {}, otherwise it will skip it. Therefore it is crucial that the expression inside if() returns either TRUE or FALSE. You can always test it by sending the exact expression directly to the console\nmy.table[['Specie']][1] == '' \u0026gt; [1] FALSE my.table[['Specie']][5] == '' \u0026gt; [1] TRUE Once we confirm that the value is empty, we enter the if statement and execute the code from step 2, which inside the function takes the form of dat[[column]][n] \u0026lt;- dat[[column]][n - 1].If the value is not empty, we simply do nothing.\nNow we can actually try the function in one of our columns\nmy.filled.table \u0026lt;- fill_merged(my.table, 'Specie') head(my.filled.table, n = 15) \u0026gt; Specie Dup Treat Rep Value \u0026gt; 1 A. cap A 0 1 34 \u0026gt; 2 A. cap AA NA NA 26 \u0026gt; 3 A. cap A 25 NA 18 \u0026gt; 4 A. cap AA NA NA 24 \u0026gt; 5 A. cap A 50 NA 11 \u0026gt; 6 A. cap AA NA NA 12 \u0026gt; 7 A. cap A 100 NA 15 \u0026gt; 8 A. cap AA NA NA 11 \u0026gt; 9 F. rub F 0 NA 25 \u0026gt; 10 F. rub FF NA NA 26 \u0026gt; 11 F. rub F 25 NA 17 \u0026gt; 12 F. rub FF NA NA 11 \u0026gt; 13 F. rub F 50 NA 13 \u0026gt; 14 F. rub FF NA NA 11 \u0026gt; 15 F. rub F 100 NA 11 Note that so far it works only for columns with character values, not numeric\nfill_merged(my.table, 'Treat') \u0026gt; Error in if (dat[[column]][n] == \u0026quot;\u0026quot;) {: missing value where TRUE/FALSE needed The reason is that only character columns produce empty strings. Numeric columns will produce NA values. Therefore, we need to add a condition to our if expression to test also if the value is NA. To do that we use double | which in R means OR\nfill_merged \u0026lt;- function(dat, column){ ## Get value of each row for(n in 1:nrow(dat)){ ## Check if it is empty if(dat[[column]][n] == '' || is.na(dat[[column]][n])){ dat[[column]][n] \u0026lt;- dat[[column]][n - 1] } } return(dat) } Now our if statement is telling to R \u0026ldquo;IF the value is empty ('') OR is NA (is.na()) then, execute this code\u0026rdquo;, and so we enter to the code inside the if-curly-braces.\nNA are not exactly values and therefore we cannot test them by using the expression\nmy.table[['Treat']][2] == NA \u0026gt; [1] NA Instead of returning TRUE or FALSE returns NA which means Not Available. To check if the value is NA or really a value we use the function is.na()\nis.na(my.table[['Treat']][2]) \u0026gt; [1] TRUE Now we can use our function for columns with numeric values also\nmy.filled.table \u0026lt;- fill_merged(my.table, 'Treat') head(my.filled.table, n = 10) \u0026gt; Specie Dup Treat Rep Value \u0026gt; 1 A. cap A 0 1 34 \u0026gt; 2 A. cap AA 0 NA 26 \u0026gt; 3 A. cap A 25 NA 18 \u0026gt; 4 AA 25 NA 24 \u0026gt; 5 A 50 NA 11 \u0026gt; 6 AA 50 NA 12 \u0026gt; 7 A 100 NA 15 \u0026gt; 8 AA 100 NA 11 \u0026gt; 9 F. rub F 0 NA 25 \u0026gt; 10 F. rub FF 0 NA 26 Check, confirm and repeat (for and if together) Now we could use our function for each column that presents this issue, but we are actually trying to apply the DRY principle. Instead we could use for() to go through all the columns where we want to apply it. There are other functions that can help with this as well such as map() and its derived functions from the package purrr.We could also write a new function that calls our first function to repeat it into each column. Feel free to experiment, for this tutorial we are going to take a different approach.\nWe are going to improve the same old function and add yet one more for loop that iterates from each column of interest and repeats the same process. This will cover the step 4 of our mapped process.\nThe implementation is actually easy, we just need to wrap the whole previous process of if\u0026rsquo;s and for\u0026rsquo;s inside a for loop that goes column by column\nfill_merged \u0026lt;- function(dat, columns.as.vector){ ## Go through the columns for(column in columns.as.vector){ ## Get value of each row for(n in 1:nrow(dat)){ ## Check if it is empty if(dat[[column]][n] == '' || is.na(dat[[column]][n])){ dat[[column]][n] \u0026lt;- dat[[column]][n - 1] } } } return(dat) } I have changed the argument for initiating the function from column to columns.as.vector. Now this will take a vector containing all the names of the columns that should be treated. Notice that in our new for loop I am declaring column to iterate over each value of column.as.vector therefore, the variable column will contain each string in the vector for each iteration. In this way we don\u0026rsquo;t need to change the rest of the code.\nNow you can call exactly the same function for each column that needs it\ntarget_cols \u0026lt;- names(my.table)[c(1,3,4)] my.filled.table \u0026lt;- fill_merged(my.table, target_cols) head(my.filled.table, n = 15) \u0026gt; Specie Dup Treat Rep Value \u0026gt; 1 A. cap A 0 1 34 \u0026gt; 2 A. cap AA 0 1 26 \u0026gt; 3 A. cap A 25 1 18 \u0026gt; 4 A. cap AA 25 1 24 \u0026gt; 5 A. cap A 50 1 11 \u0026gt; 6 A. cap AA 50 1 12 \u0026gt; 7 A. cap A 100 1 15 \u0026gt; 8 A. cap AA 100 1 11 \u0026gt; 9 F. rub F 0 1 25 \u0026gt; 10 F. rub FF 0 1 26 \u0026gt; 11 F. rub F 25 1 17 \u0026gt; 12 F. rub FF 25 1 11 \u0026gt; 13 F. rub F 50 1 13 \u0026gt; 14 F. rub FF 50 1 11 \u0026gt; 15 F. rub F 100 1 11 Also notice the trick in the first line: names(my.table) returns a vector containing all the column names of the data frame and names(my.table)[c(1,3,4)] is taking only the columns 1, 3 and 4, which are the ones that need to be fixed. This is extremely useful when you have many columns that need to be fixed\nMarking the errors You might have noticed that I\u0026rsquo;m adding text preceded by ## within the function. If you are not familiar with it, this are comments, it means that anything that is written in the same line after one # will not be evaluated by R (I use double for technical reasons of my text editor). Although this function is quite small and simple, and we know what exactly we are doing on each line thanks to the explanations, it is a good practice to add comments to your code because after a while, when you will look back at the code you might had forgotten the logic and structure. Adding comments help us to know what each piece is about, making it easier to apply changes in the future.\nIn the same way, it is a good practice to add errors when the function is expecting something in particular and we can foresee potential problems. Often we don\u0026rsquo;t foresee all the mistakes and problems that the user or we ourselves can have when using our own functions and thus, errors are usually added along the way based on the experience gathered by using the function.\nFor example, our function is expecting that at least the first row will not have empty values, otherwise it cannot go one row before to find the value to paste on it. Although it is not expected, our table can still present this situation due to human errors, for example, somebody by accident pressed Delete button somewhere on the first row in the source file. In such case R will mark some error that will be difficult to understand and track back. We might wonder for hours what we did wrong in our function only to find out that the problem comes from the data table itself. Instead we can mark our own error in advance by sending a message when the value on the first row is missing.\nAn easy way of implementing this is using the function stop(). Let\u0026rsquo;s implement our error into our function right before it copies the value from the row n - 1.\nfill_merged \u0026lt;- function(dat, columns.as.vector){ ## Go through the columns for(column in columns.as.vector){ ## Get value of each row for(n in 1:nrow(dat)){ ## Check if it is empty if(dat[[column]][n] == '' || is.na(dat[[column]][n])){ ## If it is the row 1, stop with Error if(n == 1){ stop(paste0(\u0026quot;Row 1 of column \u0026quot;, column, \u0026quot; has empty values. Check your data.\u0026quot;)) } else{ dat[[column]][n] \u0026lt;- dat[[column]][n - 1] } } } } return(dat) } If the value of the first row is empty, the function will stop, printing a message that says in which column the row no. 1 is empty. When the row is not the first, R will evaluate the code next, contained inside else{}. else is a complement for if that tell R what to do when the if() part is not fulfilled. Sometimes we can omit it, when the if() part is not fulfilled R will simply go to the next part of the code. But when we want to make sure that nothing will happen outside these options, we include else. Here we are giving only two options, either n equals 1 and the function stops with an error, or else n is not one and the function continues.\nLet\u0026rsquo;s try the error by making a copy of our data frame with the first row empty\ntest.error \u0026lt;- my.table[2:10,] fill_merged(test.error, 'Rep') \u0026gt; Error in fill_merged(test.error, \u0026quot;Rep\u0026quot;): Row 1 of column Rep has empty values. Check your data. Another misunderstanding that the user can encounter is with the argument columns.as.vector. We are expecting that the user will provide a string, or vector of strings with the names of the columns, but the user as well might think that the function is expecting the whole data as vector. We can prevent the user for doing this by adding an error at the beginning of the function.\nfill_merged \u0026lt;- function(dat, columns.as.vector){ ## Check if column names are provided as strings if(!is.character(columns.as.vector)){ stop(\u0026quot;Column names must be provided as string or vector of strings of class character\u0026quot;) } ## Go through the columns for(column in columns.as.vector){ ## Get value of each row for(n in 1:nrow(dat)){ ## Check if it is empty if(dat[[column]][n] == '' || is.na(dat[[column]][n])){ ## If it is the row 1, stop with Error if(n == 1){ stop(paste0(\u0026quot;Row 1 of column \u0026quot;, column, \u0026quot; has empty values. Check your data.\u0026quot;)) } else{ dat[[column]][n] \u0026lt;- dat[[column]][n - 1] } } } } return(dat) } We want to make sure that columns.as.vector is character. To test this, we use the function is.character(), which will return TRUE when the values inside are character, and FALSE otherwise.\na \u0026lt;- 'foo' is.character(a) \u0026gt; [1] TRUE However we want to send the error only when the value is NOT character. To tell R to test the opposite, we start the argument with the symbol !\n!is.character(a) \u0026gt; [1] FALSE Now with our new version, when the user might provide any value that is not string, the error will be triggered\nfill_merged(my.table, 1) \u0026gt; Error in fill_merged(my.table, 1): Column names must be provided as string or vector of strings of class character Still if the user provides a vector of strings, or a misspelled name of the column, our function is not aware of it. We can add one more error when column.as.vector is string but not a string that we are expecting\nfill_merged \u0026lt;- function(dat, columns.as.vector){ ## Check if column names are provided as strings if(!is.character(columns.as.vector)){ stop(\u0026quot;Column names must be provided as string or vector of strings of class character\u0026quot;) } ## Go through the columns for(column in columns.as.vector){ ## Check if the column name matches with dat column names if (!column %in% names(dat)){ stop(paste0('Column \u0026lt;', column, '\u0026gt; cannot be found in the data frame')) } ## Get value of each row for(n in 1:nrow(dat)){ ## Check if it is empty if(dat[[column]][n] == '' || is.na(dat[[column]][n])){ ## If it is the row 1, stop with Error if(n == 1){ stop(paste0(\u0026quot;Row 1 of column \u0026lt;\u0026quot;, column, \u0026quot;\u0026gt; has empty values. Check your data.\u0026quot;)) } else{ dat[[column]][n] \u0026lt;- dat[[column]][n - 1] } } } } return(dat) } Here we are implementing if (!column %in% names(dat)). Again we are using ! to tell R to test the opposite. column %in% names(dat) will take the value of column and check if it is present in the vector names(dat) (which has the names of the columns).\nLet\u0026rsquo;s test the last error by misspelling the name of one column\nfill_merged(my.table, c('Specie', 'Treatment')) \u0026gt; Error in fill_merged(my.table, c(\u0026quot;Specie\u0026quot;, \u0026quot;Treatment\u0026quot;)): Column \u0026lt;Treatment\u0026gt; cannot be found in the data frame If you can think of more errors feel free to add them, it will be good for you as a practice. However you should also try and see what happens with other potential scenarios before adding the errors yourself. Sometimes the default errors from other functions are enough to solve problems. For example, try providing to our function a data frame that does not exist, R will immediately tell you object 'x' not found.\nFinal remarks I hope that the post has helped you to have a better understanding of for() and if(), and provided you with a good guidance on how you can plan and structure functions. If something was not clear or you still have questions, or something in your code did not work as expected, feel welcome to leave us a comment below (you will need a github account for that).\nThere are many ways how you can call your function now to your future projects. One of the easiest for now would be to save it in an R script, for example fill_merged_cells.R and then you can call it from any script or R code by providing the path to your script to the function source()\nsource('~/Rscripts/fill_merged_cells.R') changing the path to the exact location of your file. Source will run all the code contained inside the .R file in the R session where you call it, making your function available for the current session.\nHere is the final form of the function for filling in empty rows produced by merged cells. I hope it will help with your work. Enjoy it!\nfill_merged \u0026lt;- function(dat, columns.as.vector){ ## Check if column names are provided as strings if(!is.character(columns.as.vector)){ stop(\u0026quot;Column names must be provided as string or vector of strings of class character\u0026quot;) } ## Go through the columns for(column in columns.as.vector){ ## Check if the column name matches with dat column names if (!column %in% names(dat)){ stop(paste0('Column \u0026lt;', column, '\u0026gt; cannot be found in the data frame')) } ## Get value of each row for(n in 1:nrow(dat)){ ## Check if it is empty if(dat[[column]][n] == '' || is.na(dat[[column]][n])){ ## If it is the row 1, stop with Error if(n == 1){ stop(paste0(\u0026quot;Row 1 of column \u0026lt;\u0026quot;, column, \u0026quot;\u0026gt; has empty values. Check your data.\u0026quot;)) } else{ dat[[column]][n] \u0026lt;- dat[[column]][n - 1] } } } } return(dat) } ","date":"2021-12-05","permalink":"https://blog-rwd-test.onrender.com/post/fill_merged_cells/","tags":["R tips","R basics","R functions"],"title":"R function to fill in merged cells"},{"content":"Background This is the first post of R with White Dwarf and I decided to start this blog with a basic tutorial. There is already a lot of information in the web about getting started with R. With a simple google search you can easily find info on how to install it, how to use R studio or other text editor, learn about the basic functions and concepts, what is a vector, a data frame, how to use them, etc. Therefore, I decided to start with a topic that is also basic and fundamental but slightly less common: Functions.\nHow to create a function is not an easy topic for non-programmers and non-mathematicians, Myself I have a background in Ecology and when I started using R for my statistical analysis I was avoiding using functions at all cost, while most of my colleagues where avoiding R fully. Many people has the idea that, as a programming language, R is really difficult to use and it should be left for the initiated ones. They end up using user interface based-software which assumes not only that the user doesn\u0026rsquo;t know about programming, but also about statistics. It makes things easy for the user but also limits the possibilities of what you can do with your data and as a result, it also what you can learn.\nIn today\u0026rsquo;s world, it is important to to have at least a basic understanding of programming. Learning how to write simple functions in R will widen your perception about R and programming by showing you that it is actually easy. I am writing this post especially for all the people who are not programmers, not statisticians and are thinking to learn R. By the end of the post I hope that you can agree with me that writing functions in R is not difficult.\nHow to write functions in R Basically, when we use R we are using functions all the time. When you want to obtain the summation of values, or the mean or standard deviation, you can simply call a function to do that\nvalues \u0026lt;- c(2, 3, 4, 5) sum(values) \u0026gt; [1] 14 As you should already know from any R tutorial, the example above is storing the values in the vector value and then calling the function sum to obtain the summation of the values. One way to create our own version of sum would be:\nmy_sum \u0026lt;- function(user.values){ cumulative.sum \u0026lt;- user.values[1] for(i in 2:length(user.values)){ cumulative.sum \u0026lt;- cumulative.sum + user.values[i] } return(cumulative.sum) } Now we can call our brand new function and obtain the same results\nmy_sum(values) \u0026gt; [1] 14 Let\u0026rsquo;s go piece by piece. Line no. 1 is simply placing the function that we are creating into the object my_sum which means that later, we can call our function using that same argument: my_func(some values). This is similar to creating a vector or data frame or variables, as you know, if you enter x \u0026lt;- 12 then each time you type x in the console it will return the value 12, and so it explains line 2, when we define cumulative.sum \u0026lt;- user.values[1] this places the first value of the vector user.values into the variable cumulative.sum. It means that now we can start by adding the second value to the cumulative.sum, then we move forward to the third value, and so on until the last element in the vector. This process is defined in the for loop: we move value by value from the second element to the last one: for(i in 2:length(user.values)), each time we stored the cumulative value in our variable cumulative.sum until we reach the last value. I will not go deep into the for loop, but I understand that it can also be somehow complicated for a beginner, if it is your case I invite you to leave us a comment (you will need a github account for that) and I might cover it in a future issue.\nOnce we are outside the for loop we have collected the final value in cumulative.sum so, we make sure that our function is returning exactly that by using return(cumulative.sum). If you have seen some other tutorials you might have noticed that the return() is not always added at the end of the function. And indeed, it is not strictly necessary (more on that later), but as a beginner it is good to start with good habits and defining what exactly you want your function to return is a good habit for your future functions.\nSimple error handling When you work with functions you need to tell the user what exactly went wrong in order to help him fix it. Even if you are writing functions only for yourself, after a while has passed you might forget all the logic behind your function and thus, obtaining errors that you don\u0026rsquo;t understand where they come from. A basic knowledge of error handling can help us prevent that.\nWhat I\u0026rsquo;m explaining here is a very basic and simple management of errors but yet, practical and useful, it can save us wasted time and headaches. It is something I wish I had learned when I started writing my first functions. Due to my ignorance it used to take me a lot of time just to figure out what was wrong with my own code.\nLet\u0026rsquo;s go back to our function. As you probably already noticed, it starts summing up from the second value in the vector, therefore if we provide only one value instead of a vector of values the result will be NA\nmy_sum(12) \u0026gt; [1] NA quite silly compared to the professional function from base-R which returns the value itself\nsum(12) \u0026gt; [1] 12 We could try to imitate the base-R sum() and continue in that direction, but instead we are going to have a little fun with simple examples of errors. Let\u0026rsquo;s say that instead of returning the value itself, we want our new function to send an error when a single value is entered. For that, we simply need to check if the value size is bigger than 1, and if not, send the error. We can achieve that with an if statement:\nmy_sum \u0026lt;- function(user.values){ if(length(user.values) == 1){ stop('We cannot sum individual values here!') } cumulative.sum \u0026lt;- user.values[1] for(i in 2:length(user.values)){ cumulative.sum \u0026lt;- cumulative.sum + user.values[i] } return(cumulative.sum) } As you can see in line 2, we will enter inside the if-part-of-code if the length of the values is one (we cannot have length smaller than 1, if we run the function without a value, R will say that the argument is missing), calling stop() which basically stops the function at that point, and exits printing whatever message you define inside it. Go ahead and try it.\nmy_sum(12) \u0026gt; Error in my_sum(12): We cannot sum individual values here! I am sure that with this basic info you can already move forward and improve it even more to send an error message when an object other than a vector is entered. Try to do it yourself and feel free to leave me a comment below if you get any trouble. Some hints: You can use the function is.vector() to test if the value entered by the user is a vector or not; and you can place one if statement inside the other, first to check if it is a vector, and secondly to check its size.\nFunction arguments You might be wondering what about the argument used as variable user.values, where does it come from? how is it defined? how does R knows how to use it? Keeping it simple, all the arguments that you define inside the parenthesis of a function will be searched by R when you execute the function and will be used accordingly. You can easily see how we were using the variable user.values to tell the rest of the program what to do with it. The function has no idea if the user will enter a single value, a vector or a data frame, this is the reason why we created the errors with stop(). As the creator of the function, it is your role to decide what kind of object you need, how to use it and how to ensure that the user knows what is wrong if an unexpected object is entered.\nYou can define as many arguments as you wish for your function, for example\nsum_four_nums \u0026lt;- function(num1, num2, num3, num4){ return(sum(num1, num2, num3, num4)) } sum_four_nums(2, 4, 6, 8) \u0026gt; [1] 20 Here we are telling R to take the four values entered by the user and sum them up. R will check the values in the order they are entered, so in our example it will associate the value 2 with our first variable num1, then the value 4 with the second variable num2 and so on. If we miss one of the values, R will tell us that one of the variables is missing\nsum_four_nums(2, 4, 6) \u0026gt; Error in sum_four_nums(2, 4, 6): argument \u0026quot;num4\u0026quot; is missing, with no default If we want to allow the user to provide only 3 values, we can initialize one of them as null\nsum_four_nums \u0026lt;- function(num1, num2, num3, num4 = NULL){ return(sum(num1, num2, num3, num4)) } sum_four_nums(2, 4, 6) \u0026gt; [1] 12 This means that we can actually initialize our variables with whatever we want to put on it, for example we can tell our function to always add 10 if only 3 values are entered by the user\nsum_four_nums \u0026lt;- function(num1, num2, num3, num4 = 10){ return(sum(num1, num2, num3, num4)) } sum_four_nums(2, 4, 6) \u0026gt; [1] 22 Also notice that we are telling R to take strictly four values, and not a vector of size 4. If we do this, R will associate the vector to the variable num1 as one object and will complain that the other arguments are missing\nsum_four_nums(c(2, 4, 6, 8)) \u0026gt; Error in sum_four_nums(c(2, 4, 6, 8)): argument \u0026quot;num2\u0026quot; is missing, with no default As I mentioned already, R is not aware of what type of object the user should enter, therefore we could as well enter only a vector, or vector and numbers, and R will simply apply the sum() function to whatever is inside it, because this is how we defined our function\nsum_four_nums(c(2, 4, 6, 8), 20, 50) \u0026gt; [1] 100 Here R is summing first all values contained in the vector, then 20 and 50, and finally the predefined 10. As you can see, the proper handling of errors is important when you want to ensure that you function does what is intended to do, or to help you or the user identify what exactly when wrong.\nFunctions without arguments You can also define functions without arguments, meaning without direct input from the user. For example, let\u0026rsquo;s write the classical Hello World!, a function that, when called, prints the sentence itself\nhello_world_function \u0026lt;- function(){ print('Hello World!') } hello_world_function() \u0026gt; [1] \u0026quot;Hello World!\u0026quot; As you can see, in line 1 when we define the function there is nothing inside the parenthesis and thus, when we call the function we don\u0026rsquo;t need to include anything inside it. This example might look silly, but sometimes we want the functions for their side effects, rather than for the values they return.\nWhen we write a function, R will search for the variable inside the function\nsum_my_vector \u0026lt;- function(){ my.vector \u0026lt;- c(10, 20, 30) return(sum(my.vector)) } sum_my_vector() \u0026gt; [1] 60 ls() \u0026gt; [1] \u0026quot;base.dir\u0026quot; \u0026quot;base.url\u0026quot; \u0026quot;changing.wd\u0026quot; \u0026gt; [4] \u0026quot;dirs\u0026quot; \u0026quot;fig.path\u0026quot; \u0026quot;func.params\u0026quot; \u0026gt; [7] \u0026quot;hello_world_function\u0026quot; \u0026quot;my_sum\u0026quot; \u0026quot;rmd.file\u0026quot; \u0026gt; [10] \u0026quot;rmd.path\u0026quot; \u0026quot;sum_four_nums\u0026quot; \u0026quot;sum_my_vector\u0026quot; \u0026gt; [13] \u0026quot;values\u0026quot; \u0026quot;work.in\u0026quot; As you can see, the vector called my.vector is created inside the function and thus, when we call it, the function returns the sum of the vector. However, when we list all the objects in memory using ls(), the object my.vector doesn\u0026rsquo;t exists. All the objects that we define inside the function live only there. If we now create an object called my.vector and call again the function, the result will not change\nmy.vector \u0026lt;- c(1, 2, 3) sum_my_vector() \u0026gt; [1] 60 ls() \u0026gt; [1] \u0026quot;base.dir\u0026quot; \u0026quot;base.url\u0026quot; \u0026quot;changing.wd\u0026quot; \u0026gt; [4] \u0026quot;dirs\u0026quot; \u0026quot;fig.path\u0026quot; \u0026quot;func.params\u0026quot; \u0026gt; [7] \u0026quot;hello_world_function\u0026quot; \u0026quot;my_sum\u0026quot; \u0026quot;my.vector\u0026quot; \u0026gt; [10] \u0026quot;rmd.file\u0026quot; \u0026quot;rmd.path\u0026quot; \u0026quot;sum_four_nums\u0026quot; \u0026gt; [13] \u0026quot;sum_my_vector\u0026quot; \u0026quot;values\u0026quot; \u0026quot;work.in\u0026quot; The reason is that R functions search for objects inside the function. Therefore, you could give the same names to objects inside and outside the functions without affecting the outcome, however this is not recommended because it might cause confusion in the future. Another reason why is not recommended is that R searches for the object inside the function first, but when it cannot find it, it searches for the object outside of the function, in your working environment (it means, what we can see listed by ls()), for example\nsum_other_vector \u0026lt;- function(){ return(sum(my.vector)) } sum_other_vector() \u0026gt; [1] 6 here I have created a similar function but this time I did not create the object my.vector inside it, therefore R is using the one that I loaded into the working environment as my.vector \u0026lt;- c(1, 2, 3).\nWe could consider the objects created inside the function as local variables because they have local effect only, and the ones defined outside of the function as global variables. Other programming languages make a clear difference of this two and handle each of them differently, often by initiating the global variables with special characters, or creating them using special functions, in order to avoid mistakes and confusion. In R you should be very careful on how you name your objects and where you use them when you are creating functions.\nOn the other hand it has the advantage that it is very easy to create functions that use the same structure of data. For example, I could create a data frame called elements that will always contain the columns called Pb, As, Cd and Zn and then just make functions that take no arguments to do all my statistics at once by calling the same table and the same columns inside them.\nWhy to write functions As mentioned above, I started writing functions when I did my Ph.D. I was working with contaminated soils and basically for all my projects I had to analyze data of concentration of elements. This means that for each project, I had to repeat the same process for each element and then, for the next project do the same for the new data and for different or more elements. Luckily my first project was only focused on 4 different elements. I did a script for the statistics and visualizations of the first element, organize the workflow, decided what would be variable and what constant, and created two functions, one for the statistics and one for the visualizations, based on the output of the first one, and then just applied the functions to the remaining 3 elements.\nWhen I got the first results of my second experiment it was related to more than 10 different elements, and that only for soils, I knew that later I\u0026rsquo;d have to do the same statistics for different parts of the plants. Therefore I decided to create a package. I simply googled how to put all my functions together in a package, installed it and then, for each of my next data results I could simply call my own functions directly in my R environment from any folder and do all the statistical analysis way faster than I can even measure.\nLearning how to write functions in R is not only intended for processes or calculations that don\u0026rsquo;t have a particular function yet (today basically everything is cover in one or another package). It can save a lot of time in any kind of work you are doing. It can reduce the time you need for your data analysis and the amount of code written in your scripts. As a result it also makes your code more organized and more understandable. It can also help you to understand better how R works, as you need to get more familiar with the type of objects used, the structures of the functions, the application of conditionals and iterative processes, etc.\nFunctions are a key element of most (probably all) programming languages and thus, learning how to create your own will also develop your programming skills and teach you how to automatize tasks. There is a general informal rule for programming that is called the DRY principle, which means Don\u0026rsquo;t Repeat Yourself. In other words, if there is a process in your code/program/script that has to be repeated at least once, it is worth it to write a function and then call it twice with the different arguments that will be variable rather than coping the whole code from the first case and pasting it where the second case needs it and only changing the arguments that are variable in the second case. The next post will be exactly about that.\nFinal remarks I hope that this tutorial has reach its goal of showing how easy and useful is to write your own functions in R. I agree that all the functions created here had minimum practical application. It is usually the case when getting started. But right in our next post we are going to write our first complete function with practical application: A function that fills empty rows generated from merged cells imported from excel.\nStay in touch!\n","date":"2021-11-30","permalink":"https://blog-rwd-test.onrender.com/post/functions/","tags":["R tips","R basics","R functions"],"title":"Functions in R"}]